# Priority Queue
It is an **Abstract data type** like `Queue`
- Every item has an additional property - the so-called **priority** value
- Element with high **priority** is served before an element with lower priority
- Usually implemented with **Heap Data Structures**, also can be implemented with **Self-Balancing Trees**
- Similar to `Queue` besides the retrieval operation will retrieve element with the higest priority first

Sometimes we do not specify the **priority** for example when implementing **Heap Data Structures** because:
- The value of an _interger_ (or _float_) can be interpreted as a **priority**
- Therefore, we can omit the **priority** when inserting new _intergers_ or _floats_ (eg. the priority of **10** will be greater than that of **5** because **10>5** so there is no need to store the priority in another variable.

The concept of `Priority Queue` naturally suggest a sorting algorithm when we have to insert all the elements to be sorted into a `Priority Queue`
- Remove the items one by one from the priority queue and it yields the sorted order.
- If we take out a given item then it will be the one with the highest priority value.
- This is how a `Heap Sort` works


# Heap Data Structure
`Heaps` are basically `Binary Trees`. Two main Binary Heap types are:
- Min Heap
  - The keys of **parent nodes** are **always less than or equal** to those of the children. The lowest key (Min value) is in the root node.
- Max Heap
  - The keys of **parent nodes** are **always greater than or equal** to those of the children. The highest key (Max value) is in the root node.

**O(1)** time complexity when searching for `Max value` or `Min value` items in a Heap Data Structure.

We can achieve O(1) TC when searching for `Max value` or `Min value` items in a `Heap` Data Structure
-- Heap is complete so it **cannot be balanced**.
- We insert every new item to the next available place.

**APPLICATIONS:** Dijkstra's Algorithm, Prim's Algorithm

# Heap Properties
1. **Completeness**: We construct the Heap from left to right across each row - of course the last row may not be fully complete.
```
      R
    /   \
   N     N
  / \    
 N   N    
```
2. Every node can have 2 children so heaps are almost-complete binary trees.
  - **Min Heap**: The parent node is always **smaller** than the child nodes (left and right nodes)
  - **Max Heap**: The parent node is always **greater** than the child nodes (left and right nodes)
  
## Max Heap

In a Max Heap, the parent nodes are always greater than the children nodes.
```
         45           The root node of a max heap is the largest item in the data structure
       /    \
     34     12
    /  \   /  \
   18   9 1    2
  / 
 11  
```

## Min Heap

In a Min Heap, the parent nodes are always smaller than the children nodes.

```
         5          The root node of a min heap is the smallest item in the data structure
       /   \
     12     8
    /  \   / \
   18  34 9   32
  / 
 98
```
### Representing Heap (Array Representation) MAX 
```
           45(0)           The root node of a max heap is the largest item in the data structure
          /     \
       34(1)    12(2)      The node with index i has left child with index 2i+1
      /  \     /     \                           and right child with index 2i+2
    18(3) 9(4) 1(5)   2(6)
   / 
 11(7)
 
Array = [ 45 , 34 , 12 , 18 , 9 , 1 , 2 , 7 ]
```

## Insertion Operations
When inserting an item into a Heap, (eg. Max Heap) if the value is greater than the parent node. You have to make a recursive swapping operations until the Max Heaps satisfies all the conditions

```
         99           
       /    \         Array = [ 99 , 92 , 23 , 78 , 5 , 12 , 21 , 2 ]
     92     23
    /  \   /  \       We can get the MAX (in a Max Heap) or MIN (In a Min Heap) item in O(1) running time
   78   5 12   21     - Ofc after that we have to rearrange the tree
  / 
 2  
```

## Remove Operations
After removing an item off a Heap, we have to check for violations and make swap operations if the Heap is violated
- Removing the **Root Node** (and usually this is the case) can be done in **O(logN)** running time

Removing an arbitrary item takes O(N) time
- We have to find it in the array with O(N) linear search and then we can remove it in O(logN)
- Searching also will take O(N) (Array-based implementation of Heap)
- The purpose of Heap is to have an efficient data structure to find and manipulate the root node (Max or Min root node)

### Removing an item (Max Heap Example)

```
         99           
       /    \         Array = [ 99 , 92 , 23 , 78 , 5 , 12 , 21 , 2 ]
     92     23
    /  \   /  \       
   78   5 12   21     
  / 
 2  
```


```
         2            Swap Operation with the smallest item
       /   \          Array = [ 2 , 92 , 23 , 78 , 5 , 12 , 21 ]
     92     23        
    /  \   /  \       Heapify operation: we have to check starting with the root node to the leaf nodes
   78   5 12   21                      whether to swap the items in order to verify the heap properties
```

```
         92                           92
       /    \                       /    \
      2     23         ->         78      23
    /  \   /   \                 /  \    /   \
   78   5 12    21              2    5  12    21

```
## Operations Complexities

**Memory Complexity:** We have N items we want to store in the heap. We have to allocate memory for an array with size **N**, hence **O(N)** memory complexity

**Find the Min/Max:** **O(1)**, because in a Heap, the highest priority item is at the root node, it is easy as `heapArray[0]` will be the item we are looking for

**Insert new item:** We can insert at the next available place, so increment the array index and insert it -> **O(1) fast**. But we have to make sure the heap properties are met ... It may take **O(logN)** time

| Operation | Time Complexity |
| --- | --- |
| Find Min/Max | O(1) |
| Remove Min/Max | O(logN) |
| Insert | O(logN) |
